#pragma version 10
#pragma typetrack false

// smart_contracts.aidchain_contracts.contract.AidchainContracts.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 0 1
    bytecblock 0x151f7c75 "campaign_counter" "milestone_counter" "delivery_counter" "voucher_counter" 0x0000000000000000 "organization_counter" "total_donations" "total_organizations" "total_milestones_completed" "campaigns" 0x0000000000000001 "deliveries" "milestones" "total_vouchers_issued" "orgs" "vouchers"
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/aidchain_contracts/contract.py:41-42
    // # Global state for counters
    // self.campaign_counter = GlobalState(UInt64(0))
    bytec_1 // "campaign_counter"
    intc_0 // 0
    app_global_put
    // smart_contracts/aidchain_contracts/contract.py:43
    // self.organization_counter = GlobalState(UInt64(0))
    bytec 6 // "organization_counter"
    intc_0 // 0
    app_global_put
    // smart_contracts/aidchain_contracts/contract.py:44
    // self.delivery_counter = GlobalState(UInt64(0))
    bytec_3 // "delivery_counter"
    intc_0 // 0
    app_global_put
    // smart_contracts/aidchain_contracts/contract.py:45
    // self.voucher_counter = GlobalState(UInt64(0))
    bytec 4 // "voucher_counter"
    intc_0 // 0
    app_global_put
    // smart_contracts/aidchain_contracts/contract.py:46
    // self.milestone_counter = GlobalState(UInt64(0))
    bytec_2 // "milestone_counter"
    intc_0 // 0
    app_global_put
    // smart_contracts/aidchain_contracts/contract.py:48-49
    // # Global state for total metrics
    // self.total_donations = GlobalState(UInt64(0))
    bytec 7 // "total_donations"
    intc_0 // 0
    app_global_put
    // smart_contracts/aidchain_contracts/contract.py:50
    // self.total_organizations = GlobalState(UInt64(0))
    bytec 8 // "total_organizations"
    intc_0 // 0
    app_global_put
    // smart_contracts/aidchain_contracts/contract.py:51
    // self.total_vouchers_issued = GlobalState(UInt64(0))
    bytec 14 // "total_vouchers_issued"
    intc_0 // 0
    app_global_put
    // smart_contracts/aidchain_contracts/contract.py:52
    // self.total_milestones_completed = GlobalState(UInt64(0))
    bytec 9 // "total_milestones_completed"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/aidchain_contracts/contract.py:39
    // class AidchainContracts(ARC4Contract):
    txn NumAppArgs
    bz main_bare_routing@34
    pushbytess 0x02bece11 0x897ad1a7 0x11d3af19 0x4fe6fd56 0x13c105b9 0x14925212 0xff511553 0x9fd6c978 0xcdba1297 0x415f641e 0xc89dcb6b 0x8ea7e0fa 0x15699001 0xc8527bbf 0x8ab6a166 0x21c4a066 0xf64ae274 0x73248567 0x84eeae63 0xc3de9a52 0x06d414ca 0x5f52df5f 0xb44f7b03 0xbf0ee02d 0xbf54ed36 0xd5b20d70 0xf37cf9ed 0xbd7909b2 0x2d89c6a1 // method "hello(string)string", method "initialize()string", method "register_organization(string,string)uint64", method "create_campaign(string,uint64,string)uint64", method "get_campaign_count()uint64", method "get_organization_count()uint64", method "create_donation(uint64)string", method "get_total_donations()uint64", method "calculate_total(uint64,uint64)uint64", method "validate_donation(uint64,string)string", method "log_delivery(string,string)uint64", method "verify_delivery(uint64,string)string", method "get_contract_stats()string", method "create_voucher_asset(string,uint64)uint64", method "distribute_vouchers(uint64,string,uint64)string", method "redeem_voucher(uint64,string,uint64)string", method "get_voucher_stats()string", method "create_milestone(uint64,uint64,string)uint64", method "complete_milestone(uint64,string)string", method "release_milestone_funds(uint64,account,uint64)string", method "get_milestone_stats()string", method "get_campaign_details(uint64)(uint64,string,uint64,uint64,string,uint64)", method "get_organization_details(uint64)(uint64,string,string,uint64)", method "get_voucher_details(uint64)(uint64,uint64,string,uint64,uint64)", method "get_milestone_details(uint64)(uint64,uint64,uint64,string,uint64,uint64)", method "get_delivery_details(uint64)(uint64,string,string,string,uint64)", method "get_milestone_count()uint64", method "get_voucher_count()uint64", method "get_delivery_count()uint64"
    txna ApplicationArgs 0
    match main_hello_route@5 main_initialize_route@6 main_register_organization_route@7 main_create_campaign_route@8 main_get_campaign_count_route@9 main_get_organization_count_route@10 main_create_donation_route@11 main_get_total_donations_route@12 main_calculate_total_route@13 main_validate_donation_route@14 main_log_delivery_route@15 main_verify_delivery_route@16 main_get_contract_stats_route@17 main_create_voucher_asset_route@18 main_distribute_vouchers_route@19 main_redeem_voucher_route@20 main_get_voucher_stats_route@21 main_create_milestone_route@22 main_complete_milestone_route@23 main_release_milestone_funds_route@24 main_get_milestone_stats_route@25 main_get_campaign_details_route@26 main_get_organization_details_route@27 main_get_voucher_details_route@28 main_get_milestone_details_route@29 main_get_delivery_details_route@30 main_get_milestone_count_route@31 main_get_voucher_count_route@32 main_get_delivery_count_route@33

main_after_if_else@36:
    // smart_contracts/aidchain_contracts/contract.py:39
    // class AidchainContracts(ARC4Contract):
    intc_0 // 0
    return

main_get_delivery_count_route@33:
    // smart_contracts/aidchain_contracts/contract.py:361
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_delivery_count
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_voucher_count_route@32:
    // smart_contracts/aidchain_contracts/contract.py:356
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_voucher_count
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_milestone_count_route@31:
    // smart_contracts/aidchain_contracts/contract.py:351
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_milestone_count
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_delivery_details_route@30:
    // smart_contracts/aidchain_contracts/contract.py:343
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/aidchain_contracts/contract.py:39
    // class AidchainContracts(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/aidchain_contracts/contract.py:343
    // @abimethod(readonly=True)
    callsub get_delivery_details
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_milestone_details_route@29:
    // smart_contracts/aidchain_contracts/contract.py:337
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/aidchain_contracts/contract.py:39
    // class AidchainContracts(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/aidchain_contracts/contract.py:337
    // @abimethod(readonly=True)
    callsub get_milestone_details
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_voucher_details_route@28:
    // smart_contracts/aidchain_contracts/contract.py:331
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/aidchain_contracts/contract.py:39
    // class AidchainContracts(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/aidchain_contracts/contract.py:331
    // @abimethod(readonly=True)
    callsub get_voucher_details
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_organization_details_route@27:
    // smart_contracts/aidchain_contracts/contract.py:325
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/aidchain_contracts/contract.py:39
    // class AidchainContracts(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/aidchain_contracts/contract.py:325
    // @abimethod(readonly=True)
    callsub get_organization_details
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_campaign_details_route@26:
    // smart_contracts/aidchain_contracts/contract.py:319
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/aidchain_contracts/contract.py:39
    // class AidchainContracts(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/aidchain_contracts/contract.py:319
    // @abimethod(readonly=True)
    callsub get_campaign_details
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_milestone_stats_route@25:
    // smart_contracts/aidchain_contracts/contract.py:312
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    pushbytes 0x151f7c75001e4d696c6573746f6e65207374617469737469637320617661696c61626c65
    log
    intc_1 // 1
    return

main_release_milestone_funds_route@24:
    // smart_contracts/aidchain_contracts/contract.py:295
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/aidchain_contracts/contract.py:39
    // class AidchainContracts(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    txnas Accounts
    txna ApplicationArgs 3
    btoi
    // smart_contracts/aidchain_contracts/contract.py:295
    // @abimethod()
    callsub release_milestone_funds
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_complete_milestone_route@23:
    // smart_contracts/aidchain_contracts/contract.py:279
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/aidchain_contracts/contract.py:39
    // class AidchainContracts(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/aidchain_contracts/contract.py:279
    // @abimethod()
    callsub complete_milestone
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_create_milestone_route@22:
    // smart_contracts/aidchain_contracts/contract.py:256
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/aidchain_contracts/contract.py:39
    // class AidchainContracts(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    extract 2 0
    // smart_contracts/aidchain_contracts/contract.py:256
    // @abimethod()
    callsub create_milestone
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_voucher_stats_route@21:
    // smart_contracts/aidchain_contracts/contract.py:250
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    pushbytes 0x151f7c75001c566f7563686572207374617469737469637320617661696c61626c65
    log
    intc_1 // 1
    return

main_redeem_voucher_route@20:
    // smart_contracts/aidchain_contracts/contract.py:239
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/aidchain_contracts/contract.py:39
    // class AidchainContracts(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    extract 2 0
    txna ApplicationArgs 3
    btoi
    // smart_contracts/aidchain_contracts/contract.py:239
    // @abimethod()
    callsub redeem_voucher
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_distribute_vouchers_route@19:
    // smart_contracts/aidchain_contracts/contract.py:232
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    pushbytes 0x151f7c7500204465627567206d6f64653a20766f756368657273206469737472696275746564
    log
    intc_1 // 1
    return

main_create_voucher_asset_route@18:
    // smart_contracts/aidchain_contracts/contract.py:196
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/aidchain_contracts/contract.py:39
    // class AidchainContracts(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    // smart_contracts/aidchain_contracts/contract.py:196
    // @abimethod()
    callsub create_voucher_asset
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_contract_stats_route@17:
    // smart_contracts/aidchain_contracts/contract.py:191
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    pushbytes 0x151f7c75001d436f6e7472616374207374617469737469637320617661696c61626c65
    log
    intc_1 // 1
    return

main_verify_delivery_route@16:
    // smart_contracts/aidchain_contracts/contract.py:175
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/aidchain_contracts/contract.py:39
    // class AidchainContracts(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/aidchain_contracts/contract.py:175
    // @abimethod()
    callsub verify_delivery
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_log_delivery_route@15:
    // smart_contracts/aidchain_contracts/contract.py:158
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/aidchain_contracts/contract.py:39
    // class AidchainContracts(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/aidchain_contracts/contract.py:158
    // @abimethod()
    callsub log_delivery
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_validate_donation_route@14:
    // smart_contracts/aidchain_contracts/contract.py:150
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/aidchain_contracts/contract.py:39
    // class AidchainContracts(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/aidchain_contracts/contract.py:150
    // @abimethod()
    callsub validate_donation
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_calculate_total_route@13:
    // smart_contracts/aidchain_contracts/contract.py:145
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/aidchain_contracts/contract.py:39
    // class AidchainContracts(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    // smart_contracts/aidchain_contracts/contract.py:145
    // @abimethod()
    callsub calculate_total
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_total_donations_route@12:
    // smart_contracts/aidchain_contracts/contract.py:140
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_total_donations
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_create_donation_route@11:
    // smart_contracts/aidchain_contracts/contract.py:123
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/aidchain_contracts/contract.py:39
    // class AidchainContracts(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/aidchain_contracts/contract.py:123
    // @abimethod()
    callsub create_donation
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_organization_count_route@10:
    // smart_contracts/aidchain_contracts/contract.py:118
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_organization_count
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_campaign_count_route@9:
    // smart_contracts/aidchain_contracts/contract.py:113
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_campaign_count
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_create_campaign_route@8:
    // smart_contracts/aidchain_contracts/contract.py:95
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/aidchain_contracts/contract.py:39
    // class AidchainContracts(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    extract 2 0
    // smart_contracts/aidchain_contracts/contract.py:95
    // @abimethod()
    callsub create_campaign
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_register_organization_route@7:
    // smart_contracts/aidchain_contracts/contract.py:78
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/aidchain_contracts/contract.py:39
    // class AidchainContracts(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/aidchain_contracts/contract.py:78
    // @abimethod()
    callsub register_organization
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_initialize_route@6:
    // smart_contracts/aidchain_contracts/contract.py:64
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub initialize
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_hello_route@5:
    // smart_contracts/aidchain_contracts/contract.py:60
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/aidchain_contracts/contract.py:39
    // class AidchainContracts(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/aidchain_contracts/contract.py:60
    // @abimethod()
    callsub hello
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_bare_routing@34:
    // smart_contracts/aidchain_contracts/contract.py:39
    // class AidchainContracts(ARC4Contract):
    txn OnCompletion
    bnz main_after_if_else@36
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts.aidchain_contracts.contract.AidchainContracts.hello(name: bytes) -> bytes:
hello:
    // smart_contracts/aidchain_contracts/contract.py:60-61
    // @abimethod()
    // def hello(self, name: String) -> String:
    proto 1 1
    // smart_contracts/aidchain_contracts/contract.py:62
    // return "Hello, " + name
    pushbytes "Hello, "
    frame_dig -1
    concat
    retsub


// smart_contracts.aidchain_contracts.contract.AidchainContracts.initialize() -> bytes:
initialize:
    // smart_contracts/aidchain_contracts/contract.py:67
    // self.campaign_counter.value = UInt64(0)
    bytec_1 // "campaign_counter"
    intc_0 // 0
    app_global_put
    // smart_contracts/aidchain_contracts/contract.py:68
    // self.organization_counter.value = UInt64(0)
    bytec 6 // "organization_counter"
    intc_0 // 0
    app_global_put
    // smart_contracts/aidchain_contracts/contract.py:69
    // self.delivery_counter.value = UInt64(0)
    bytec_3 // "delivery_counter"
    intc_0 // 0
    app_global_put
    // smart_contracts/aidchain_contracts/contract.py:70
    // self.voucher_counter.value = UInt64(0)
    bytec 4 // "voucher_counter"
    intc_0 // 0
    app_global_put
    // smart_contracts/aidchain_contracts/contract.py:71
    // self.milestone_counter.value = UInt64(0)
    bytec_2 // "milestone_counter"
    intc_0 // 0
    app_global_put
    // smart_contracts/aidchain_contracts/contract.py:72
    // self.total_donations.value = UInt64(0)
    bytec 7 // "total_donations"
    intc_0 // 0
    app_global_put
    // smart_contracts/aidchain_contracts/contract.py:73
    // self.total_organizations.value = UInt64(0)
    bytec 8 // "total_organizations"
    intc_0 // 0
    app_global_put
    // smart_contracts/aidchain_contracts/contract.py:74
    // self.total_vouchers_issued.value = UInt64(0)
    bytec 14 // "total_vouchers_issued"
    intc_0 // 0
    app_global_put
    // smart_contracts/aidchain_contracts/contract.py:75
    // self.total_milestones_completed.value = UInt64(0)
    bytec 9 // "total_milestones_completed"
    intc_0 // 0
    app_global_put
    // smart_contracts/aidchain_contracts/contract.py:76
    // return String("Contract initialized successfully")
    pushbytes "Contract initialized successfully"
    retsub


// smart_contracts.aidchain_contracts.contract.AidchainContracts.register_organization(org_name: bytes, wallet_address: bytes) -> uint64:
register_organization:
    // smart_contracts/aidchain_contracts/contract.py:78-79
    // @abimethod()
    // def register_organization(self, org_name: String, wallet_address: String) -> UInt64:
    proto 2 1
    // smart_contracts/aidchain_contracts/contract.py:81
    // self.organization_counter.value += UInt64(1)
    intc_0 // 0
    bytec 6 // "organization_counter"
    app_global_get_ex
    assert // check self.organization_counter exists
    intc_1 // 1
    +
    bytec 6 // "organization_counter"
    dig 1
    app_global_put
    // smart_contracts/aidchain_contracts/contract.py:86
    // id=ARC4UInt64(org_id),
    dup
    itob
    // smart_contracts/aidchain_contracts/contract.py:87
    // name=ARC4String(org_name),
    frame_dig -2
    len
    itob
    extract 6 2
    frame_dig -2
    concat
    // smart_contracts/aidchain_contracts/contract.py:88
    // wallet_address=ARC4String(wallet_address),
    frame_dig -1
    len
    itob
    extract 6 2
    frame_dig -1
    concat
    // smart_contracts/aidchain_contracts/contract.py:84-90
    // # Store organization data in BoxMap
    // self.organizations[ARC4UInt64(org_id)] = OrganizationInfo(
    //     id=ARC4UInt64(org_id),
    //     name=ARC4String(org_name),
    //     wallet_address=ARC4String(wallet_address),
    //     verification_level=ARC4UInt64(0)  # 0 = unverified initially
    // )
    dig 2
    pushbytes 0x0014
    concat
    dig 2
    len
    pushint 20 // 20
    +
    itob
    extract 6 2
    concat
    // smart_contracts/aidchain_contracts/contract.py:89
    // verification_level=ARC4UInt64(0)  # 0 = unverified initially
    bytec 5 // 0x0000000000000000
    // smart_contracts/aidchain_contracts/contract.py:84-90
    // # Store organization data in BoxMap
    // self.organizations[ARC4UInt64(org_id)] = OrganizationInfo(
    //     id=ARC4UInt64(org_id),
    //     name=ARC4String(org_name),
    //     wallet_address=ARC4String(wallet_address),
    //     verification_level=ARC4UInt64(0)  # 0 = unverified initially
    // )
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/aidchain_contracts/contract.py:84-85
    // # Store organization data in BoxMap
    // self.organizations[ARC4UInt64(org_id)] = OrganizationInfo(
    bytec 15 // "orgs"
    uncover 2
    concat
    // smart_contracts/aidchain_contracts/contract.py:84-90
    // # Store organization data in BoxMap
    // self.organizations[ARC4UInt64(org_id)] = OrganizationInfo(
    //     id=ARC4UInt64(org_id),
    //     name=ARC4String(org_name),
    //     wallet_address=ARC4String(wallet_address),
    //     verification_level=ARC4UInt64(0)  # 0 = unverified initially
    // )
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/aidchain_contracts/contract.py:92
    // self.total_organizations.value += UInt64(1)
    intc_0 // 0
    bytec 8 // "total_organizations"
    app_global_get_ex
    assert // check self.total_organizations exists
    intc_1 // 1
    +
    bytec 8 // "total_organizations"
    swap
    app_global_put
    // smart_contracts/aidchain_contracts/contract.py:93
    // return org_id
    retsub


// smart_contracts.aidchain_contracts.contract.AidchainContracts.create_campaign(title: bytes, target: uint64, creator: bytes) -> uint64:
create_campaign:
    // smart_contracts/aidchain_contracts/contract.py:95-96
    // @abimethod()
    // def create_campaign(self, title: String, target: UInt64, creator: String) -> UInt64:
    proto 3 1
    // smart_contracts/aidchain_contracts/contract.py:98
    // self.campaign_counter.value += UInt64(1)
    intc_0 // 0
    bytec_1 // "campaign_counter"
    app_global_get_ex
    assert // check self.campaign_counter exists
    intc_1 // 1
    +
    bytec_1 // "campaign_counter"
    dig 1
    app_global_put
    // smart_contracts/aidchain_contracts/contract.py:103
    // id=ARC4UInt64(campaign_id),
    dup
    itob
    // smart_contracts/aidchain_contracts/contract.py:104
    // title=ARC4String(title),
    frame_dig -3
    len
    itob
    extract 6 2
    frame_dig -3
    concat
    // smart_contracts/aidchain_contracts/contract.py:105
    // target=ARC4UInt64(target),
    frame_dig -2
    itob
    // smart_contracts/aidchain_contracts/contract.py:107
    // creator=ARC4String(creator),
    frame_dig -1
    len
    itob
    extract 6 2
    frame_dig -1
    concat
    // smart_contracts/aidchain_contracts/contract.py:101-109
    // # Store campaign data in BoxMap
    // self.campaigns[ARC4UInt64(campaign_id)] = CampaignInfo(
    //     id=ARC4UInt64(campaign_id),
    //     title=ARC4String(title),
    //     target=ARC4UInt64(target),
    //     raised=ARC4UInt64(0),  # No funds raised initially
    //     creator=ARC4String(creator),
    //     active=ARC4UInt64(1)  # 1 = active
    // )
    dig 3
    pushbytes 0x0024
    concat
    dig 3
    len
    pushint 36 // 36
    +
    swap
    uncover 3
    concat
    // smart_contracts/aidchain_contracts/contract.py:106
    // raised=ARC4UInt64(0),  # No funds raised initially
    bytec 5 // 0x0000000000000000
    // smart_contracts/aidchain_contracts/contract.py:101-109
    // # Store campaign data in BoxMap
    // self.campaigns[ARC4UInt64(campaign_id)] = CampaignInfo(
    //     id=ARC4UInt64(campaign_id),
    //     title=ARC4String(title),
    //     target=ARC4UInt64(target),
    //     raised=ARC4UInt64(0),  # No funds raised initially
    //     creator=ARC4String(creator),
    //     active=ARC4UInt64(1)  # 1 = active
    // )
    concat
    swap
    itob
    extract 6 2
    concat
    // smart_contracts/aidchain_contracts/contract.py:108
    // active=ARC4UInt64(1)  # 1 = active
    bytec 11 // 0x0000000000000001
    // smart_contracts/aidchain_contracts/contract.py:101-109
    // # Store campaign data in BoxMap
    // self.campaigns[ARC4UInt64(campaign_id)] = CampaignInfo(
    //     id=ARC4UInt64(campaign_id),
    //     title=ARC4String(title),
    //     target=ARC4UInt64(target),
    //     raised=ARC4UInt64(0),  # No funds raised initially
    //     creator=ARC4String(creator),
    //     active=ARC4UInt64(1)  # 1 = active
    // )
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/aidchain_contracts/contract.py:101-102
    // # Store campaign data in BoxMap
    // self.campaigns[ARC4UInt64(campaign_id)] = CampaignInfo(
    bytec 10 // "campaigns"
    uncover 2
    concat
    // smart_contracts/aidchain_contracts/contract.py:101-109
    // # Store campaign data in BoxMap
    // self.campaigns[ARC4UInt64(campaign_id)] = CampaignInfo(
    //     id=ARC4UInt64(campaign_id),
    //     title=ARC4String(title),
    //     target=ARC4UInt64(target),
    //     raised=ARC4UInt64(0),  # No funds raised initially
    //     creator=ARC4String(creator),
    //     active=ARC4UInt64(1)  # 1 = active
    // )
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/aidchain_contracts/contract.py:111
    // return campaign_id
    retsub


// smart_contracts.aidchain_contracts.contract.AidchainContracts.get_campaign_count() -> uint64:
get_campaign_count:
    // smart_contracts/aidchain_contracts/contract.py:116
    // return self.campaign_counter.value
    intc_0 // 0
    bytec_1 // "campaign_counter"
    app_global_get_ex
    assert // check self.campaign_counter exists
    retsub


// smart_contracts.aidchain_contracts.contract.AidchainContracts.get_organization_count() -> uint64:
get_organization_count:
    // smart_contracts/aidchain_contracts/contract.py:121
    // return self.organization_counter.value
    intc_0 // 0
    bytec 6 // "organization_counter"
    app_global_get_ex
    assert // check self.organization_counter exists
    retsub


// smart_contracts.aidchain_contracts.contract.AidchainContracts.create_donation(campaign_id: uint64) -> bytes:
create_donation:
    // smart_contracts/aidchain_contracts/contract.py:123-124
    // @abimethod()
    // def create_donation(self, campaign_id: UInt64) -> String:
    proto 1 1
    // smart_contracts/aidchain_contracts/contract.py:126-127
    // # Validate campaign exists using professional patterns
    // assert campaign_id <= self.campaign_counter.value, "Campaign ID out of range"
    intc_0 // 0
    bytec_1 // "campaign_counter"
    app_global_get_ex
    assert // check self.campaign_counter exists
    frame_dig -1
    >=
    assert // Campaign ID out of range
    // smart_contracts/aidchain_contracts/contract.py:128
    // assert campaign_id != UInt64(0), "Campaign ID cannot be zero"
    frame_dig -1
    assert // Campaign ID cannot be zero
    // smart_contracts/aidchain_contracts/contract.py:129
    // assert ARC4UInt64(campaign_id) in self.campaigns, "Campaign not found"
    frame_dig -1
    itob
    bytec 10 // "campaigns"
    swap
    concat
    box_len
    bury 1
    assert // Campaign not found
    // smart_contracts/aidchain_contracts/contract.py:135-136
    // # Add to total donations (real blockchain state)
    // self.total_donations.value += donation_amount
    intc_0 // 0
    bytec 7 // "total_donations"
    app_global_get_ex
    assert // check self.total_donations exists
    // smart_contracts/aidchain_contracts/contract.py:131-133
    // # For testing purposes, simulate a donation amount
    // # In production, this would get the actual payment amount from Txn.amount
    // donation_amount = UInt64(1000)  # Simulated donation amount
    pushint 1000 // 1000
    // smart_contracts/aidchain_contracts/contract.py:135-136
    // # Add to total donations (real blockchain state)
    // self.total_donations.value += donation_amount
    +
    bytec 7 // "total_donations"
    swap
    app_global_put
    // smart_contracts/aidchain_contracts/contract.py:138
    // return String("Donation recorded successfully")
    pushbytes "Donation recorded successfully"
    retsub


// smart_contracts.aidchain_contracts.contract.AidchainContracts.get_total_donations() -> uint64:
get_total_donations:
    // smart_contracts/aidchain_contracts/contract.py:143
    // return self.total_donations.value
    intc_0 // 0
    bytec 7 // "total_donations"
    app_global_get_ex
    assert // check self.total_donations exists
    retsub


// smart_contracts.aidchain_contracts.contract.AidchainContracts.calculate_total(amount1: uint64, amount2: uint64) -> uint64:
calculate_total:
    // smart_contracts/aidchain_contracts/contract.py:145-146
    // @abimethod()
    // def calculate_total(self, amount1: UInt64, amount2: UInt64) -> UInt64:
    proto 2 1
    // smart_contracts/aidchain_contracts/contract.py:148
    // return amount1 + amount2
    frame_dig -2
    frame_dig -1
    +
    retsub


// smart_contracts.aidchain_contracts.contract.AidchainContracts.validate_donation(amount: uint64, donor: bytes) -> bytes:
validate_donation:
    // smart_contracts/aidchain_contracts/contract.py:150-151
    // @abimethod()
    // def validate_donation(self, amount: UInt64, donor: String) -> String:
    proto 2 1
    // smart_contracts/aidchain_contracts/contract.py:153
    // if amount > UInt64(0):
    frame_dig -2
    bz validate_donation_else_body@2
    // smart_contracts/aidchain_contracts/contract.py:154
    // return String("Valid donation from ") + donor
    pushbytes "Valid donation from "
    frame_dig -1
    concat
    retsub

validate_donation_else_body@2:
    // smart_contracts/aidchain_contracts/contract.py:156
    // return String("Invalid donation amount")
    pushbytes "Invalid donation amount"
    retsub


// smart_contracts.aidchain_contracts.contract.AidchainContracts.log_delivery(recipient: bytes, location: bytes) -> uint64:
log_delivery:
    // smart_contracts/aidchain_contracts/contract.py:158-159
    // @abimethod()
    // def log_delivery(self, recipient: String, location: String) -> UInt64:
    proto 2 1
    // smart_contracts/aidchain_contracts/contract.py:161
    // self.delivery_counter.value += UInt64(1)
    intc_0 // 0
    bytec_3 // "delivery_counter"
    app_global_get_ex
    assert // check self.delivery_counter exists
    intc_1 // 1
    +
    bytec_3 // "delivery_counter"
    dig 1
    app_global_put
    // smart_contracts/aidchain_contracts/contract.py:166
    // id=ARC4UInt64(delivery_id),
    dup
    itob
    // smart_contracts/aidchain_contracts/contract.py:167
    // recipient=ARC4String(recipient),
    frame_dig -2
    len
    itob
    extract 6 2
    frame_dig -2
    concat
    // smart_contracts/aidchain_contracts/contract.py:168
    // location=ARC4String(location),
    frame_dig -1
    len
    itob
    extract 6 2
    frame_dig -1
    concat
    // smart_contracts/aidchain_contracts/contract.py:164-171
    // # Store delivery data in BoxMap
    // self.deliveries[ARC4UInt64(delivery_id)] = DeliveryRecord(
    //     id=ARC4UInt64(delivery_id),
    //     recipient=ARC4String(recipient),
    //     location=ARC4String(location),
    //     agent=ARC4String(""),  # Empty initially
    //     verified=ARC4UInt64(0)  # 0 = not verified initially
    // )
    dig 2
    pushbytes 0x0016
    concat
    dig 2
    len
    pushint 22 // 22
    +
    dup
    itob
    extract 6 2
    uncover 2
    swap
    concat
    dig 2
    len
    uncover 2
    +
    itob
    extract 6 2
    concat
    // smart_contracts/aidchain_contracts/contract.py:170
    // verified=ARC4UInt64(0)  # 0 = not verified initially
    bytec 5 // 0x0000000000000000
    // smart_contracts/aidchain_contracts/contract.py:164-171
    // # Store delivery data in BoxMap
    // self.deliveries[ARC4UInt64(delivery_id)] = DeliveryRecord(
    //     id=ARC4UInt64(delivery_id),
    //     recipient=ARC4String(recipient),
    //     location=ARC4String(location),
    //     agent=ARC4String(""),  # Empty initially
    //     verified=ARC4UInt64(0)  # 0 = not verified initially
    // )
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/aidchain_contracts/contract.py:169
    // agent=ARC4String(""),  # Empty initially
    pushbytes 0x0000
    // smart_contracts/aidchain_contracts/contract.py:164-171
    // # Store delivery data in BoxMap
    // self.deliveries[ARC4UInt64(delivery_id)] = DeliveryRecord(
    //     id=ARC4UInt64(delivery_id),
    //     recipient=ARC4String(recipient),
    //     location=ARC4String(location),
    //     agent=ARC4String(""),  # Empty initially
    //     verified=ARC4UInt64(0)  # 0 = not verified initially
    // )
    concat
    // smart_contracts/aidchain_contracts/contract.py:164-165
    // # Store delivery data in BoxMap
    // self.deliveries[ARC4UInt64(delivery_id)] = DeliveryRecord(
    bytec 12 // "deliveries"
    uncover 2
    concat
    // smart_contracts/aidchain_contracts/contract.py:164-171
    // # Store delivery data in BoxMap
    // self.deliveries[ARC4UInt64(delivery_id)] = DeliveryRecord(
    //     id=ARC4UInt64(delivery_id),
    //     recipient=ARC4String(recipient),
    //     location=ARC4String(location),
    //     agent=ARC4String(""),  # Empty initially
    //     verified=ARC4UInt64(0)  # 0 = not verified initially
    // )
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/aidchain_contracts/contract.py:173
    // return delivery_id
    retsub


// smart_contracts.aidchain_contracts.contract.AidchainContracts.verify_delivery(delivery_id: uint64, agent: bytes) -> bytes:
verify_delivery:
    // smart_contracts/aidchain_contracts/contract.py:175-176
    // @abimethod()
    // def verify_delivery(self, delivery_id: UInt64, agent: String) -> String:
    proto 2 1
    // smart_contracts/aidchain_contracts/contract.py:178-179
    // # Validate delivery exists
    // assert delivery_id <= self.delivery_counter.value, "Delivery ID out of range"
    intc_0 // 0
    bytec_3 // "delivery_counter"
    app_global_get_ex
    assert // check self.delivery_counter exists
    frame_dig -2
    >=
    assert // Delivery ID out of range
    // smart_contracts/aidchain_contracts/contract.py:180
    // assert delivery_id != UInt64(0), "Delivery ID cannot be zero"
    frame_dig -2
    assert // Delivery ID cannot be zero
    // smart_contracts/aidchain_contracts/contract.py:181
    // assert ARC4UInt64(delivery_id) in self.deliveries, "Delivery not found"
    frame_dig -2
    itob
    bytec 12 // "deliveries"
    swap
    concat
    dup
    box_len
    bury 1
    assert // Delivery not found
    // smart_contracts/aidchain_contracts/contract.py:183-184
    // # Update delivery status in BoxMap
    // delivery_info = self.deliveries[ARC4UInt64(delivery_id)].copy()
    dup
    box_get
    assert // check self.deliveries entry exists
    // smart_contracts/aidchain_contracts/contract.py:185
    // delivery_info.verified = ARC4UInt64(1)  # Mark as verified
    bytec 11 // 0x0000000000000001
    replace2 14
    // smart_contracts/aidchain_contracts/contract.py:186
    // delivery_info.agent = ARC4String(agent)  # Set the verifying agent
    frame_dig -1
    len
    itob
    extract 6 2
    frame_dig -1
    concat
    dig 1
    pushint 12 // 12
    extract_uint16
    uncover 2
    intc_0 // 0
    uncover 2
    extract3
    swap
    concat
    // smart_contracts/aidchain_contracts/contract.py:187
    // self.deliveries[ARC4UInt64(delivery_id)] = delivery_info.copy()
    dig 1
    box_del
    pop
    box_put
    // smart_contracts/aidchain_contracts/contract.py:189
    // return String("Delivery verified by agent: ") + agent
    pushbytes "Delivery verified by agent: "
    frame_dig -1
    concat
    retsub


// smart_contracts.aidchain_contracts.contract.AidchainContracts.create_voucher_asset(asset_name: bytes, total_supply: uint64) -> bytes:
create_voucher_asset:
    // smart_contracts/aidchain_contracts/contract.py:196-197
    // @abimethod()
    // def create_voucher_asset(self, asset_name: String, total_supply: UInt64) -> ARC4UInt64:
    proto 2 1
    // smart_contracts/aidchain_contracts/contract.py:199-211
    // # Create actual ASA token using inner transaction
    // txn_result = itxn.AssetConfig(
    //     asset_name=asset_name,
    //     unit_name=String("VOUCHER"),
    //     total=total_supply,
    //     decimals=0,
    //     default_frozen=False,
    //     manager=Global.current_application_address,
    //     reserve=Global.current_application_address,
    //     freeze=Global.current_application_address,
    //     clawback=Global.current_application_address,
    //     fee=Global.min_txn_fee,  # Use minimum transaction fee
    // ).submit()
    itxn_begin
    // smart_contracts/aidchain_contracts/contract.py:210
    // fee=Global.min_txn_fee,  # Use minimum transaction fee
    global MinTxnFee
    // smart_contracts/aidchain_contracts/contract.py:206
    // manager=Global.current_application_address,
    global CurrentApplicationAddress
    // smart_contracts/aidchain_contracts/contract.py:207-209
    // reserve=Global.current_application_address,
    // freeze=Global.current_application_address,
    // clawback=Global.current_application_address,
    dupn 3
    itxn_field ConfigAssetClawback
    itxn_field ConfigAssetFreeze
    itxn_field ConfigAssetReserve
    itxn_field ConfigAssetManager
    // smart_contracts/aidchain_contracts/contract.py:205
    // default_frozen=False,
    intc_0 // 0
    itxn_field ConfigAssetDefaultFrozen
    // smart_contracts/aidchain_contracts/contract.py:204
    // decimals=0,
    intc_0 // 0
    itxn_field ConfigAssetDecimals
    frame_dig -1
    itxn_field ConfigAssetTotal
    // smart_contracts/aidchain_contracts/contract.py:202
    // unit_name=String("VOUCHER"),
    pushbytes "VOUCHER"
    itxn_field ConfigAssetUnitName
    frame_dig -2
    itxn_field ConfigAssetName
    // smart_contracts/aidchain_contracts/contract.py:199-200
    // # Create actual ASA token using inner transaction
    // txn_result = itxn.AssetConfig(
    pushint 3 // acfg
    itxn_field TypeEnum
    itxn_field Fee
    // smart_contracts/aidchain_contracts/contract.py:199-211
    // # Create actual ASA token using inner transaction
    // txn_result = itxn.AssetConfig(
    //     asset_name=asset_name,
    //     unit_name=String("VOUCHER"),
    //     total=total_supply,
    //     decimals=0,
    //     default_frozen=False,
    //     manager=Global.current_application_address,
    //     reserve=Global.current_application_address,
    //     freeze=Global.current_application_address,
    //     clawback=Global.current_application_address,
    //     fee=Global.min_txn_fee,  # Use minimum transaction fee
    // ).submit()
    itxn_submit
    itxn CreatedAssetID
    // smart_contracts/aidchain_contracts/contract.py:216-217
    // # Increment voucher counter
    // self.voucher_counter.value += UInt64(1)
    intc_0 // 0
    bytec 4 // "voucher_counter"
    app_global_get_ex
    assert // check self.voucher_counter exists
    intc_1 // 1
    +
    bytec 4 // "voucher_counter"
    dig 1
    app_global_put
    // smart_contracts/aidchain_contracts/contract.py:222
    // id=ARC4UInt64(voucher_id),
    itob
    // smart_contracts/aidchain_contracts/contract.py:223
    // asset_id=ARC4UInt64(asset_id),
    swap
    itob
    // smart_contracts/aidchain_contracts/contract.py:224
    // name=ARC4String(asset_name),
    frame_dig -2
    len
    itob
    extract 6 2
    frame_dig -2
    concat
    // smart_contracts/aidchain_contracts/contract.py:225
    // total_supply=ARC4UInt64(total_supply),
    frame_dig -1
    itob
    // smart_contracts/aidchain_contracts/contract.py:220-227
    // # Store voucher info in BoxMap
    // self.vouchers[ARC4UInt64(voucher_id)] = VoucherInfo(
    //     id=ARC4UInt64(voucher_id),
    //     asset_id=ARC4UInt64(asset_id),
    //     name=ARC4String(asset_name),
    //     total_supply=ARC4UInt64(total_supply),
    //     issued=ARC4UInt64(0)  # No tokens issued yet
    // )
    dig 3
    dig 3
    concat
    pushbytes 0x0022
    concat
    swap
    concat
    // smart_contracts/aidchain_contracts/contract.py:226
    // issued=ARC4UInt64(0)  # No tokens issued yet
    bytec 5 // 0x0000000000000000
    // smart_contracts/aidchain_contracts/contract.py:220-227
    // # Store voucher info in BoxMap
    // self.vouchers[ARC4UInt64(voucher_id)] = VoucherInfo(
    //     id=ARC4UInt64(voucher_id),
    //     asset_id=ARC4UInt64(asset_id),
    //     name=ARC4String(asset_name),
    //     total_supply=ARC4UInt64(total_supply),
    //     issued=ARC4UInt64(0)  # No tokens issued yet
    // )
    concat
    swap
    concat
    // smart_contracts/aidchain_contracts/contract.py:220-221
    // # Store voucher info in BoxMap
    // self.vouchers[ARC4UInt64(voucher_id)] = VoucherInfo(
    bytec 16 // "vouchers"
    uncover 3
    concat
    // smart_contracts/aidchain_contracts/contract.py:220-227
    // # Store voucher info in BoxMap
    // self.vouchers[ARC4UInt64(voucher_id)] = VoucherInfo(
    //     id=ARC4UInt64(voucher_id),
    //     asset_id=ARC4UInt64(asset_id),
    //     name=ARC4String(asset_name),
    //     total_supply=ARC4UInt64(total_supply),
    //     issued=ARC4UInt64(0)  # No tokens issued yet
    // )
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/aidchain_contracts/contract.py:229-230
    // # Return the actual asset ID created by the blockchain
    // return ARC4UInt64(asset_id)
    retsub


// smart_contracts.aidchain_contracts.contract.AidchainContracts.redeem_voucher(voucher_id: uint64, merchant: bytes, amount: uint64) -> bytes:
redeem_voucher:
    // smart_contracts/aidchain_contracts/contract.py:239-240
    // @abimethod()
    // def redeem_voucher(self, voucher_id: UInt64, merchant: String, amount: UInt64) -> String:
    proto 3 1
    // smart_contracts/aidchain_contracts/contract.py:242
    // if voucher_id > self.voucher_counter.value or voucher_id == UInt64(0):
    intc_0 // 0
    bytec 4 // "voucher_counter"
    app_global_get_ex
    assert // check self.voucher_counter exists
    frame_dig -3
    <
    bnz redeem_voucher_if_body@2
    frame_dig -3
    bnz redeem_voucher_after_if_else@3

redeem_voucher_if_body@2:
    // smart_contracts/aidchain_contracts/contract.py:243
    // return String("Invalid voucher ID")
    pushbytes "Invalid voucher ID"
    retsub

redeem_voucher_after_if_else@3:
    // smart_contracts/aidchain_contracts/contract.py:245
    // if amount == UInt64(0):
    frame_dig -1
    bnz redeem_voucher_after_if_else@5
    // smart_contracts/aidchain_contracts/contract.py:246
    // return String("Amount must be greater than zero")
    pushbytes "Amount must be greater than zero"
    retsub

redeem_voucher_after_if_else@5:
    // smart_contracts/aidchain_contracts/contract.py:248
    // return String("Vouchers redeemed at ") + merchant
    pushbytes "Vouchers redeemed at "
    frame_dig -2
    concat
    retsub


// smart_contracts.aidchain_contracts.contract.AidchainContracts.create_milestone(campaign_id: uint64, target_amount: uint64, description: bytes) -> uint64:
create_milestone:
    // smart_contracts/aidchain_contracts/contract.py:256-257
    // @abimethod()
    // def create_milestone(self, campaign_id: UInt64, target_amount: UInt64, description: String) -> UInt64:
    proto 3 1
    // smart_contracts/aidchain_contracts/contract.py:259-260
    // # Validate campaign exists
    // assert campaign_id <= self.campaign_counter.value, "Campaign ID out of range"
    intc_0 // 0
    bytec_1 // "campaign_counter"
    app_global_get_ex
    assert // check self.campaign_counter exists
    frame_dig -3
    >=
    assert // Campaign ID out of range
    // smart_contracts/aidchain_contracts/contract.py:261
    // assert campaign_id != UInt64(0), "Campaign ID cannot be zero"
    frame_dig -3
    assert // Campaign ID cannot be zero
    // smart_contracts/aidchain_contracts/contract.py:262
    // assert ARC4UInt64(campaign_id) in self.campaigns, "Campaign not found"
    frame_dig -3
    itob
    bytec 10 // "campaigns"
    dig 1
    concat
    box_len
    bury 1
    assert // Campaign not found
    // smart_contracts/aidchain_contracts/contract.py:264
    // self.milestone_counter.value += UInt64(1)
    intc_0 // 0
    bytec_2 // "milestone_counter"
    app_global_get_ex
    assert // check self.milestone_counter exists
    intc_1 // 1
    +
    bytec_2 // "milestone_counter"
    dig 1
    app_global_put
    // smart_contracts/aidchain_contracts/contract.py:269
    // id=ARC4UInt64(milestone_id),
    dup
    itob
    // smart_contracts/aidchain_contracts/contract.py:271
    // target_amount=ARC4UInt64(target_amount),
    frame_dig -2
    itob
    // smart_contracts/aidchain_contracts/contract.py:272
    // description=ARC4String(description),
    frame_dig -1
    len
    itob
    extract 6 2
    frame_dig -1
    concat
    // smart_contracts/aidchain_contracts/contract.py:267-275
    // # Store milestone data in BoxMap
    // self.milestones[ARC4UInt64(milestone_id)] = MilestoneInfo(
    //     id=ARC4UInt64(milestone_id),
    //     campaign_id=ARC4UInt64(campaign_id),
    //     target_amount=ARC4UInt64(target_amount),
    //     description=ARC4String(description),
    //     completed=ARC4UInt64(0),  # 0 = pending
    //     funds_released=ARC4UInt64(0)  # 0 = not released
    // )
    dig 2
    uncover 5
    concat
    uncover 2
    concat
    pushbytes 0x002a
    concat
    // smart_contracts/aidchain_contracts/contract.py:273
    // completed=ARC4UInt64(0),  # 0 = pending
    bytec 5 // 0x0000000000000000
    // smart_contracts/aidchain_contracts/contract.py:267-275
    // # Store milestone data in BoxMap
    // self.milestones[ARC4UInt64(milestone_id)] = MilestoneInfo(
    //     id=ARC4UInt64(milestone_id),
    //     campaign_id=ARC4UInt64(campaign_id),
    //     target_amount=ARC4UInt64(target_amount),
    //     description=ARC4String(description),
    //     completed=ARC4UInt64(0),  # 0 = pending
    //     funds_released=ARC4UInt64(0)  # 0 = not released
    // )
    concat
    // smart_contracts/aidchain_contracts/contract.py:274
    // funds_released=ARC4UInt64(0)  # 0 = not released
    bytec 5 // 0x0000000000000000
    // smart_contracts/aidchain_contracts/contract.py:267-275
    // # Store milestone data in BoxMap
    // self.milestones[ARC4UInt64(milestone_id)] = MilestoneInfo(
    //     id=ARC4UInt64(milestone_id),
    //     campaign_id=ARC4UInt64(campaign_id),
    //     target_amount=ARC4UInt64(target_amount),
    //     description=ARC4String(description),
    //     completed=ARC4UInt64(0),  # 0 = pending
    //     funds_released=ARC4UInt64(0)  # 0 = not released
    // )
    concat
    swap
    concat
    // smart_contracts/aidchain_contracts/contract.py:267-268
    // # Store milestone data in BoxMap
    // self.milestones[ARC4UInt64(milestone_id)] = MilestoneInfo(
    bytec 13 // "milestones"
    uncover 2
    concat
    // smart_contracts/aidchain_contracts/contract.py:267-275
    // # Store milestone data in BoxMap
    // self.milestones[ARC4UInt64(milestone_id)] = MilestoneInfo(
    //     id=ARC4UInt64(milestone_id),
    //     campaign_id=ARC4UInt64(campaign_id),
    //     target_amount=ARC4UInt64(target_amount),
    //     description=ARC4String(description),
    //     completed=ARC4UInt64(0),  # 0 = pending
    //     funds_released=ARC4UInt64(0)  # 0 = not released
    // )
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/aidchain_contracts/contract.py:277
    // return milestone_id
    retsub


// smart_contracts.aidchain_contracts.contract.AidchainContracts.complete_milestone(milestone_id: uint64, proof: bytes) -> bytes:
complete_milestone:
    // smart_contracts/aidchain_contracts/contract.py:279-280
    // @abimethod()
    // def complete_milestone(self, milestone_id: UInt64, proof: String) -> String:
    proto 2 1
    // smart_contracts/aidchain_contracts/contract.py:282-283
    // # Validate milestone exists
    // assert milestone_id <= self.milestone_counter.value, "Milestone ID out of range"
    intc_0 // 0
    bytec_2 // "milestone_counter"
    app_global_get_ex
    assert // check self.milestone_counter exists
    frame_dig -2
    >=
    assert // Milestone ID out of range
    // smart_contracts/aidchain_contracts/contract.py:284
    // assert milestone_id != UInt64(0), "Milestone ID cannot be zero"
    frame_dig -2
    assert // Milestone ID cannot be zero
    // smart_contracts/aidchain_contracts/contract.py:285
    // assert ARC4UInt64(milestone_id) in self.milestones, "Milestone not found"
    frame_dig -2
    itob
    bytec 13 // "milestones"
    swap
    concat
    dup
    box_len
    bury 1
    assert // Milestone not found
    // smart_contracts/aidchain_contracts/contract.py:287-288
    // # Update milestone status in BoxMap
    // milestone_info = self.milestones[ARC4UInt64(milestone_id)].copy()
    dup
    box_get
    assert // check self.milestones entry exists
    // smart_contracts/aidchain_contracts/contract.py:289
    // milestone_info.completed = ARC4UInt64(1)  # Mark as completed
    bytec 11 // 0x0000000000000001
    replace2 26
    // smart_contracts/aidchain_contracts/contract.py:290
    // self.milestones[ARC4UInt64(milestone_id)] = milestone_info.copy()
    dig 1
    box_del
    pop
    box_put
    // smart_contracts/aidchain_contracts/contract.py:292
    // self.total_milestones_completed.value += UInt64(1)
    intc_0 // 0
    bytec 9 // "total_milestones_completed"
    app_global_get_ex
    assert // check self.total_milestones_completed exists
    intc_1 // 1
    +
    bytec 9 // "total_milestones_completed"
    swap
    app_global_put
    // smart_contracts/aidchain_contracts/contract.py:293
    // return String("Milestone completed with proof: ") + proof
    pushbytes "Milestone completed with proof: "
    frame_dig -1
    concat
    retsub


// smart_contracts.aidchain_contracts.contract.AidchainContracts.release_milestone_funds(milestone_id: uint64, recipient: bytes, amount: uint64) -> bytes:
release_milestone_funds:
    // smart_contracts/aidchain_contracts/contract.py:295-296
    // @abimethod()
    // def release_milestone_funds(self, milestone_id: UInt64, recipient: Account, amount: UInt64) -> String:
    proto 3 1
    // smart_contracts/aidchain_contracts/contract.py:298-299
    // # Validate using professional patterns
    // assert milestone_id <= self.milestone_counter.value, "Milestone ID out of range"
    intc_0 // 0
    bytec_2 // "milestone_counter"
    app_global_get_ex
    assert // check self.milestone_counter exists
    frame_dig -3
    >=
    assert // Milestone ID out of range
    // smart_contracts/aidchain_contracts/contract.py:300
    // assert milestone_id != UInt64(0), "Milestone ID cannot be zero"
    frame_dig -3
    assert // Milestone ID cannot be zero
    // smart_contracts/aidchain_contracts/contract.py:301
    // assert amount > UInt64(0), "Amount must be greater than zero"
    frame_dig -1
    assert // Amount must be greater than zero
    // smart_contracts/aidchain_contracts/contract.py:303-308
    // # Make actual payment on blockchain
    // itxn.Payment(
    //     receiver=recipient,
    //     amount=amount,
    //     fee=Global.min_txn_fee,  # Use minimum transaction fee
    // ).submit()
    itxn_begin
    // smart_contracts/aidchain_contracts/contract.py:307
    // fee=Global.min_txn_fee,  # Use minimum transaction fee
    global MinTxnFee
    frame_dig -1
    itxn_field Amount
    frame_dig -2
    itxn_field Receiver
    // smart_contracts/aidchain_contracts/contract.py:303-304
    // # Make actual payment on blockchain
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    itxn_field Fee
    // smart_contracts/aidchain_contracts/contract.py:303-308
    // # Make actual payment on blockchain
    // itxn.Payment(
    //     receiver=recipient,
    //     amount=amount,
    //     fee=Global.min_txn_fee,  # Use minimum transaction fee
    // ).submit()
    itxn_submit
    // smart_contracts/aidchain_contracts/contract.py:310
    // return String("Real blockchain payment sent for milestone")
    pushbytes "Real blockchain payment sent for milestone"
    retsub


// smart_contracts.aidchain_contracts.contract.AidchainContracts.get_campaign_details(campaign_id: bytes) -> bytes:
get_campaign_details:
    // smart_contracts/aidchain_contracts/contract.py:319-320
    // @abimethod(readonly=True)
    // def get_campaign_details(self, campaign_id: ARC4UInt64) -> CampaignInfo:
    proto 1 1
    // smart_contracts/aidchain_contracts/contract.py:322
    // assert campaign_id in self.campaigns, "Campaign not found"
    bytec 10 // "campaigns"
    frame_dig -1
    concat
    dup
    box_len
    bury 1
    assert // Campaign not found
    // smart_contracts/aidchain_contracts/contract.py:323
    // return self.campaigns[campaign_id]
    box_get
    assert // check self.campaigns entry exists
    retsub


// smart_contracts.aidchain_contracts.contract.AidchainContracts.get_organization_details(org_id: bytes) -> bytes:
get_organization_details:
    // smart_contracts/aidchain_contracts/contract.py:325-326
    // @abimethod(readonly=True)
    // def get_organization_details(self, org_id: ARC4UInt64) -> OrganizationInfo:
    proto 1 1
    // smart_contracts/aidchain_contracts/contract.py:328
    // assert org_id in self.organizations, "Organization not found"
    bytec 15 // "orgs"
    frame_dig -1
    concat
    dup
    box_len
    bury 1
    assert // Organization not found
    // smart_contracts/aidchain_contracts/contract.py:329
    // return self.organizations[org_id]
    box_get
    assert // check self.organizations entry exists
    retsub


// smart_contracts.aidchain_contracts.contract.AidchainContracts.get_voucher_details(voucher_id: bytes) -> bytes:
get_voucher_details:
    // smart_contracts/aidchain_contracts/contract.py:331-332
    // @abimethod(readonly=True)
    // def get_voucher_details(self, voucher_id: ARC4UInt64) -> VoucherInfo:
    proto 1 1
    // smart_contracts/aidchain_contracts/contract.py:334
    // assert voucher_id in self.vouchers, "Voucher not found"
    bytec 16 // "vouchers"
    frame_dig -1
    concat
    dup
    box_len
    bury 1
    assert // Voucher not found
    // smart_contracts/aidchain_contracts/contract.py:335
    // return self.vouchers[voucher_id]
    box_get
    assert // check self.vouchers entry exists
    retsub


// smart_contracts.aidchain_contracts.contract.AidchainContracts.get_milestone_details(milestone_id: bytes) -> bytes:
get_milestone_details:
    // smart_contracts/aidchain_contracts/contract.py:337-338
    // @abimethod(readonly=True)
    // def get_milestone_details(self, milestone_id: ARC4UInt64) -> MilestoneInfo:
    proto 1 1
    // smart_contracts/aidchain_contracts/contract.py:340
    // assert milestone_id in self.milestones, "Milestone not found"
    bytec 13 // "milestones"
    frame_dig -1
    concat
    dup
    box_len
    bury 1
    assert // Milestone not found
    // smart_contracts/aidchain_contracts/contract.py:341
    // return self.milestones[milestone_id]
    box_get
    assert // check self.milestones entry exists
    retsub


// smart_contracts.aidchain_contracts.contract.AidchainContracts.get_delivery_details(delivery_id: bytes) -> bytes:
get_delivery_details:
    // smart_contracts/aidchain_contracts/contract.py:343-344
    // @abimethod(readonly=True)
    // def get_delivery_details(self, delivery_id: ARC4UInt64) -> DeliveryRecord:
    proto 1 1
    // smart_contracts/aidchain_contracts/contract.py:346
    // assert delivery_id in self.deliveries, "Delivery not found"
    bytec 12 // "deliveries"
    frame_dig -1
    concat
    dup
    box_len
    bury 1
    assert // Delivery not found
    // smart_contracts/aidchain_contracts/contract.py:347
    // return self.deliveries[delivery_id]
    box_get
    assert // check self.deliveries entry exists
    retsub


// smart_contracts.aidchain_contracts.contract.AidchainContracts.get_milestone_count() -> uint64:
get_milestone_count:
    // smart_contracts/aidchain_contracts/contract.py:354
    // return self.milestone_counter.value
    intc_0 // 0
    bytec_2 // "milestone_counter"
    app_global_get_ex
    assert // check self.milestone_counter exists
    retsub


// smart_contracts.aidchain_contracts.contract.AidchainContracts.get_voucher_count() -> uint64:
get_voucher_count:
    // smart_contracts/aidchain_contracts/contract.py:359
    // return self.voucher_counter.value
    intc_0 // 0
    bytec 4 // "voucher_counter"
    app_global_get_ex
    assert // check self.voucher_counter exists
    retsub


// smart_contracts.aidchain_contracts.contract.AidchainContracts.get_delivery_count() -> uint64:
get_delivery_count:
    // smart_contracts/aidchain_contracts/contract.py:364
    // return self.delivery_counter.value
    intc_0 // 0
    bytec_3 // "delivery_counter"
    app_global_get_ex
    assert // check self.delivery_counter exists
    retsub
